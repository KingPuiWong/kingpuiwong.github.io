<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JAVA面试  （Author：黄景培 ， email ：&amp;#54;&amp;#x31;&amp;#48;&amp;#48;&amp;#x39;&amp;#x30;&amp;#50;&amp;#x33;&amp;#x38;&amp;#64;&amp;#x71;&amp;#113;&amp;#46;&amp;#99;&amp;#x6f;&amp;#109;）">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试">
<meta property="og:url" content="http://example.com/2021/03/19/Java%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="JAVA面试  （Author：黄景培 ， email ：&amp;#54;&amp;#x31;&amp;#48;&amp;#48;&amp;#x39;&amp;#x30;&amp;#50;&amp;#x33;&amp;#x38;&amp;#64;&amp;#x71;&amp;#113;&amp;#46;&amp;#99;&amp;#x6f;&amp;#109;）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/markdownpicture/85">
<meta property="og:image" content="d:/markdownpicture/83">
<meta property="og:image" content="d:/markdownpicture/84">
<meta property="og:image" content="d:/markdownpicture/77">
<meta property="og:image" content="d:/markdownpicture/58.png">
<meta property="og:image" content="d:/markdownpicture/59.png">
<meta property="og:image" content="d:/markdownpicture/60.png">
<meta property="og:image" content="d:/markdownpicture/61.png">
<meta property="og:image" content="d:/markdownpicture/63.png">
<meta property="og:image" content="d:/markdownpicture/64.png">
<meta property="og:image" content="d:/markdownpicture/65.png">
<meta property="og:image" content="d:/markdownpicture/66.png">
<meta property="og:image" content="d:/markdownpicture/75.png">
<meta property="og:image" content="d:/markdownpicture/67.png">
<meta property="og:image" content="d:/markdownpicture/68.png">
<meta property="og:image" content="d:/markdownpicture/73.png">
<meta property="og:image" content="d:/markdownpicture/72.png">
<meta property="og:image" content="d:/markdownpicture/81">
<meta property="og:image" content="d:/markdownpicture/82">
<meta property="og:image" content="d:/markdownpicture/76.png">
<meta property="article:published_time" content="2021-03-19T14:04:22.000Z">
<meta property="article:modified_time" content="2021-03-24T12:33:07.944Z">
<meta property="article:author" content="KingPuiWong">
<meta property="article:tag" content="Java面试总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/markdownpicture/85">

<link rel="canonical" href="http://example.com/2021/03/19/Java%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java面试 | My Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">to be continued</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/Java%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KingPuiWong">
      <meta itemprop="description" content="My Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 22:04:22" itemprop="dateCreated datePublished" datetime="2021-03-19T22:04:22+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-24 20:33:07" itemprop="dateModified" datetime="2021-03-24T20:33:07+08:00">2021-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/19/Java%E9%9D%A2%E8%AF%95/" class="post-meta-item leancloud_visitors" data-flag-title="Java面试" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/19/Java%E9%9D%A2%E8%AF%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/19/Java%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> JAVA面试  （Author：黄景培 ， email ：<a href="mailto:&#54;&#x31;&#48;&#48;&#x39;&#x30;&#50;&#x33;&#x38;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;">&#54;&#x31;&#48;&#48;&#x39;&#x30;&#50;&#x33;&#x38;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;</a>）</p>
<span id="more"></span>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li><p>Thread和Runnable</p>
<ul>
<li><p>联系和区别?(Thread实现Runnable、Runnable资源共享) </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35888875/article/details/78356249">联系和区别</a></p>
<!-- more --></li>
</ul>
</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>原因（资源互斥、资源不足、资源分配不当、进程推进顺序不当等）    </li>
<li>四个必要条件<ul>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资 源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源条件</li>
</ul>
</li>
<li>避免死锁：1.使用资源申请的有序性原则。2.银行家算法</li>
</ul>
</li>
<li><p>线量池（分类、区别、上限情况）</p>
<ul>
<li><p>CachedTheadPool</p>
<ul>
<li>Integeer.MAX_VALUE</li>
<li>空闲回收</li>
</ul>
</li>
<li><p>FixedThreadPool</p>
<ul>
<li>指定数量</li>
<li>空闲不释放</li>
<li>任务满时等待</li>
</ul>
</li>
<li><p>SingleTheadExecutor</p>
<ul>
<li>单线程</li>
<li>顺序执行</li>
</ul>
</li>
<li><p>ScheduleThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Creates a thread pool that can schedule commands to run after a given delay,or to execute periodicall.</span><br><span class="line"><span class="meta">@param</span> corePoolSize the number of threads to keep in the pool,</span><br><span class="line">even <span class="keyword">if</span> they are idle</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/richaaaard/p/6599184.html">线量池</a> </p>
</li>
</ul>
</li>
<li><p>wait、notify、notifyAll   </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f7d4819b7b24">wait\notify\notifyAll</a>   </li>
</ul>
</li>
<li><p>synchronized  </p>
<ul>
<li>作用于静态和非静态域的作用    <ul>
<li>非静态锁对象</li>
<li>静态锁类、所有对象同一锁  </li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010842515/article/details/65443084">synchronized</a> </li>
</ul>
</li>
<li><p>synchronized与lock    </p>
<ul>
<li>synchrinize<ul>
<li>作用于方法或代码块，作用于代码块时需要对象参与控制  </li>
<li>托管给JVM</li>
<li>悲观锁(阻塞、cpu上下文切换)</li>
</ul>
</li>
<li>lock<ul>
<li>显示指定起始和终止位置</li>
<li>JAVA代码实现</li>
<li>悲观锁和乐观锁<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wjh123/p/11129548.html">区别</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">ss</a>  </li>
</ul>
</li>
</ul>
</li>
<li><p>volatile</p>
<ul>
<li>保证变量可见性</li>
<li>不能保证变量的原子性（多线程colatile变量++）</li>
<li>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">volatite</a></li>
</ul>
</li>
<li><p>CAS</p>
<ul>
<li>在Java中，锁在并发处理中占据了一席之地，但是使用锁有一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起，这会导致线程上下文的切换和重新调度开销。Java提供了非阻塞的volatile关键字来解决共享变量的可见性问题，这在一定程度上弥补了锁带来的开销问题，但是volatile只能保证共享变量的可见性，不能解决读-改-写等的原子性问题。CAS即Compare and Swap，其是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性。</li>
<li>CAS有四个操作数，分别为：对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是如果对象obj内存偏移量为valueOffset的变量值为expect，则使用新的值update替换旧的值expect，这是处理器提供的一个原子性指令。</li>
<li>ABA问题</li>
</ul>
</li>
<li><p>悲观锁、乐观锁</p>
<ul>
<li>悲观锁    <ul>
<li>  假定会发生冲突，屏蔽所有可能会破环数据完整性的操作</li>
</ul>
</li>
<li>乐观锁<ul>
<li>假设不会发生冲突，只在提交操作时检查是否违法数据完整性</li>
</ul>
</li>
</ul>
</li>
<li><p>调度(抢占式,非抢占式)</p>
<ul>
<li>非抢占式<br>-需要多少CPU时间片就给多少，其他线程一直等待(可能饿死)</li>
<li>抢占式<ul>
<li>操作系统复负责CPU时间分片的分配</li>
<li>当前进程的使用结束后，重新决定下一个的使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>理解、条件、常见序列化方式<ul>
<li>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、对象的类型的信息和存储在该对象的数据的类型<br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-serialization.html">0</a></li>
</ul>
</li>
<li>Serializable、Externalizable<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huhx/p/serializable.html">1</a> </li>
<li>非序列化（Transient、静态）(序列化保存的是对象的状态、静态变量数是类的状态、因此序列化并不保存静态变量)   </li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>IO与NIO的区别<ul>
<li>IO    <ul>
<li>面向流</li>
<li>阻塞IO</li>
</ul>
</li>
<li>NIO   <ul>
<li>面向缓存</li>
<li>非阻塞IO</li>
<li>选择器<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6576588.html">IO\NIO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p>分类、区别和应用(受检异常、非受检异常) </p>
</li>
<li><p>继承关系(Throwable、Error、Exception)</p>
<ul>
<li><p>Error</p>
<ul>
<li>java运行时系统的内部错误和资源耗尽错误</li>
<li>StackOverflowError、OutOfMemoryError</li>
</ul>
</li>
<li><p>Exception</p>
<ul>
<li><p>RunTimeException</p>
</li>
<li><p>CheckedException<br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">异常处理</a>      </p>
<p><img src="D:\markdownpicture\85" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul>
<li>理解、使用举例<ul>
<li>Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li>
<li>作用阶段<ul>
<li>运行时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>List</p>
</li>
<li><p>HashMap</p>
<ul>
<li><p>原理(get和put、碰撞)</p>
</li>
<li><p>hashCode和equals</p>
<ul>
<li>自定义类equals，使用Object的equals，即==</li>
<li>部分实现重写，例如String，比较的是内容</li>
<li>hashCode在Map元素存取时计算地址</li>
</ul>
</li>
<li><p>线程安全(为什么不安全？HashTable和ConcurrentHashMap？)</p>
<ul>
<li><p>寻址，后操作覆盖前操作</p>
</li>
<li><p>ConcurrentHashMap使用分段锁Segment 段数扩充</p>
</li>
<li><p>HashTable使用Synchronized，竞争激烈时效率低    </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">线程安全</a></p>
</li>
<li><p>多线程下会发生的安全问题</p>
<ul>
<li><p>JDK1.7会rehash时可能会出现循环链表的情况</p>
</li>
<li><p>JDK1.8下的HashMap当链表长度大于8时会转换成红黑树从而避免这个问题，但</p>
<p>多线程下仍然会有不安全的情况发生</p>
<ul>
<li><p>put的时候导致的多线程数据不一样</p>
<ul>
<li><p>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
</li>
<li><p>触发fail-fast机制</p>
<ul>
<li>一个线程利用迭代器迭代时，另一个线程做插入删除操作，造成迭代的fast-fail。</li>
</ul>
</li>
<li><p>并发下扩容数据丢失</p>
<ul>
<li>如果多个线程同时检测到元素个数超过数组大小 * loadFactor，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/better-farther-world2099/articles/11027589.html">hashMap多线程不安全</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有序(是否有序？LinkHashMap原理？TreeMap原理？他们是如何保证有序的？)  </p>
<ul>
<li>LinkedHashMap，内部增加了一个链表，用以存放元素的顺序<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8f4f58b4b8ab">LinkedHashMap</a></li>
<li>TreeMap，实现了SortedMap接口，这意味着它可以对元素进行排序</li>
</ul>
</li>
<li><p>深浅拷贝  </p>
<ul>
<li><p>浅拷贝</p>
<ul>
<li>只复制对象引用，俩个引用指向同一个对象，在内存中占同一块内存</li>
<li>实现浅拷贝的方式有俩种：=和Map.putAll()</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量  </li>
<li>实现深拷贝：HashMap.putAll()</li>
</ul>
</li>
<li><p>使用Map调用putAll()方法，并不是真正意义上的拷贝，Map对象B只是对Map对象A进行了引用，当Map对象A中内容发生变化时，Map对象B也会发生变化</p>
</li>
<li><p>使用HashMap调用putAll()方法才是真正意义上的拷贝。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Marydon20170307/p/9132042.html">深浅拷贝</a>   </p>
</li>
</ul>
</li>
<li><p>时间复杂度</p>
<p><img src="D:\markdownpicture\83" alt="1608715439249"></p>
<p><img src="D:\markdownpicture\84" alt="1608715485851"></p>
</li>
<li><p>计算日活量</p>
<p><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556438/viewspace-2218085/">DAU</a></p>
</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><p>计算机网络的体系结构</p>
<p><img src="D:\markdownpicture\77" alt="1607047230091"></p>
</li>
<li><p>TCP/IP的分层管理</p>
<ul>
<li>TCP/IP协议族按层次分别为一下4层：应用层、传输层、网络层和数据链路层</li>
<li>应用层：<code>决定了向用户提供应用服务时通信的活动。</code>FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务和Http协议  </li>
<li>传输层：<code>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据</code><br>传输 。TCP（Transmission Control<br>Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报<br>协议）。</li>
<li>网络层：<code>用来处理在网络上流动的数据包.</code>数据包时网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计<br>算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所<br>起的作用就是在众多的选项内选择一条传输路线。    </li>
<li>数据链路层：<code>用来处理连接网络的硬件部分</code> 包括控制操作系统、硬件的设备驱<br>动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等<br>物理可见部分（还包括连接器等一切传输媒介）  </li>
</ul>
</li>
<li><p>TCP/IP 通信传输流<br><img src="D:\markdownpicture/58.png">        </p>
</li>
<li><p>与HTTP关系密切的协议:IP、TCP 和DNS </p>
<ul>
<li>负责传输的 IP 协议    <ul>
<li>IP（Internet Protocol）网际协议位于网络层</li>
<li>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方<br>那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC<br>地址（Media Access Control Address）   </li>
<li>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定<br>地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC<br>地址基本上不会更改。</li>
<li>使用 ARP 协议凭借 MAC 地址进行通信<ul>
<li>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网<br>（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转<br>才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC<br>地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address<br>Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方<br>的 IP 地址就可以反查出对应的 MAC 地址。  </li>
</ul>
</li>
</ul>
</li>
<li>确保可靠性的 TCP 协议 <ul>
<li>按层次分，TCP 位于传输层，提供可靠的字节流服务  </li>
<li>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手<br><img src="D:\markdownpicture/59.png">    </li>
</ul>
</li>
<li>负责域名解析的 DNS 服务<ul>
<li>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的<br> 协议。它提供域名到 IP 地址之间的解析服务。    </li>
</ul>
</li>
<li>各种协议与 HTTP 协议的关系<br><img src="D:\markdownpicture/60.png">  </li>
</ul>
</li>
<li><p>URI 和 URL    </p>
</li>
</ul>
<h3 id="确保WEB安全的HTTPS"><a href="#确保WEB安全的HTTPS" class="headerlink" title="确保WEB安全的HTTPS"></a>确保WEB安全的HTTPS</h3><ul>
<li>HTTP的缺点<ul>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭纂改。</li>
</ul>
</li>
<li>通信使用明文可能会被窃听<ul>
<li>TCP/IP是可能被窃听的网络</li>
<li>加密处理防止被窃听</li>
</ul>
</li>
<li>加密处理防止被窃听<ul>
<li><code>通信的加密</code>（HTTP通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容），与SSL组合使用的HTTP被称为HTTPS</li>
<li><code>内容的加密</code>（客户端对HTTP报文进行加密处理后再发送请求）<br><img src="D:/markdownpicture/61.png"></li>
</ul>
</li>
<li>不验证通信方发身份就可能遭遇伪装<ul>
<li>任何人都可发起请求<ul>
<li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限</li>
</ul>
</li>
</ul>
</li>
<li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li>
<li>HTTPS是身披SSL外壳的HTTP     - HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已<br><img src="D:\markdownpicture/63.png"></li>
<li>HTTPS采用混合加密机制<ul>
<li>采用共享密钥加密和公开密钥加密二者并用的混合加密机制。<ul>
<li>在交换密钥环节使用公开密钥加密，通信交换报文使用共享密钥加密。<br><img src="D:\markdownpicture/64.png"></li>
</ul>
</li>
<li>验证公开密钥正确性的证书(公开密钥可能被攻击者替换)<br><img src="D:\markdownpicture/65.png"> </li>
</ul>
</li>
</ul>
<h3 id="HTTPS的完整性保护"><a href="#HTTPS的完整性保护" class="headerlink" title="HTTPS的完整性保护"></a>HTTPS的完整性保护</h3><ul>
<li>在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</li>
</ul>
<h3 id="URL地址栏输入地址后，发生了什么？"><a href="#URL地址栏输入地址后，发生了什么？" class="headerlink" title="URL地址栏输入地址后，发生了什么？"></a>URL地址栏输入地址后，发生了什么？</h3><ul>
<li>1.DNS域名解析；</li>
<li>2.建立TCP连接；</li>
<li>3.发送HTTP请求；</li>
<li>4.服务器处理请求；</li>
<li>5.返回响应结果；</li>
<li>6.关闭TCP连接；</li>
<li>7.浏览器解析HTML；</li>
<li>8.浏览器布局渲染；<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazylqy/p/7110357.html">🔗</a></li>
</ul>
<h3 id="请求转发与重定向的区别"><a href="#请求转发与重定向的区别" class="headerlink" title="请求转发与重定向的区别"></a>请求转发与重定向的区别</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5345527.html">🔗</a></p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul>
<li><p>简单来说就是通过提供 可鉴别 的 数字信息 验证 自身身份 的一种方式。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥 (私钥不可泄露),由 接受者 持有与私钥对应的 公钥 ，能够在 接受 到来自发送者信息时用于 验证 其身份。<br><img src="D:\markdownpicture/66.png">  </p>
</li>
<li><p><img src="D:\markdownpicture/75.png"></p>
</li>
</ul>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><ul>
<li><p>对称加密</p>
<ul>
<li>又称为 公开密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。<br><img src="D:\markdownpicture/67.png">  </li>
</ul>
</li>
<li><p>非对称加密</p>
<ul>
<li>非对称加密算法，又称为共享密钥加密算法。它需要两个密钥，一个称为公开密钥(publickey)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。因为加密和解密使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。<br><img src="D:/markdownpicture/68.png"></li>
<li>如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。</li>
<li>如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。</li>
</ul>
<h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><ul>
<li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li>
<li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li>
<li>应用层发送数据时定长发送。</li>
</ul>
</li>
</ul>
<h2 id="Redis复习"><a href="#Redis复习" class="headerlink" title="Redis复习"></a>Redis复习</h2><p><img src="D:\markdownpicture/73.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-data-types.md">redis</a></p>
<h3 id="为什么zset数据结构使用跳表而不使用红黑树"><a href="#为什么zset数据结构使用跳表而不使用红黑树" class="headerlink" title="为什么zset数据结构使用跳表而不使用红黑树"></a>为什么zset数据结构使用跳表而不使用红黑树</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhutianrong520/article/details/102715414?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">🔗</a></p>
<h3 id="如何实现Redis的分布锁"><a href="#如何实现Redis的分布锁" class="headerlink" title="如何实现Redis的分布锁"></a>如何实现Redis的分布锁</h3><ul>
<li></li>
</ul>
<p>​    </p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring常问问题"><a href="#Spring常问问题" class="headerlink" title="Spring常问问题"></a>Spring常问问题</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg">链接</a></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM的加载过程"><a href="#JVM的加载过程" class="headerlink" title="JVM的加载过程"></a>JVM的加载过程</h3><ul>
<li>jvm将类加载过程分成加载、连接、初始化三个阶段，其中连接阶段又细分为验证、准备、解析三个阶段<ul>
<li>装载：将java字节码以二进制的方式读入到jvm内存中，然后将二进制数据流按照字节码规范解析成jvm内部的运行时数据结构。</li>
<li>连接： 做一些加载完成之后的验证工作，和初始化之前的准备工作。<ul>
<li>验证 ：用于保证加载的字节码符合java语言的规范</li>
<li>准备 ：为类的静态变量分配内存，并设置jvm默认的初始值。对于非静态的变量，则不会为它们分配内存。基本数据类型中默认初始值为0.布尔值初始化为false。引用类型为null.</li>
<li>解析 : 查找类常量池中的类、字段、方法、接口的符号引用，将他们替换成直接引用的过程.</li>
</ul>
</li>
<li>初始化 ： 根据用户程序中的初始化语句为类的静态变量赋予正确的初始值。这里初始化执行逻辑最终会体现在类构造器&lt;clinit()&gt;方法中。该方法由编译器在编译阶段生成。它封装了俩部分内容：静态变量的初始化语句和静态语句块。<ul>
<li>初始化的执行时机：<ul>
<li>new</li>
<li>反射</li>
<li>初始化子类的时候，会触发父类的初始化</li>
<li>作为程序入口直接运行时的主类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><ul>
<li>虚拟机遇到new指令时，首先先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程。</li>
<li>为对象分配空间，把一块固定大小的内存从java堆里划分出来。如果java堆是那种齐整的，一边放已经用的内存，另一边放没有用的内存，这样就有一个中间指针隔开两个区域，只要把这个指针移动到相应位置即可，这种方法叫做“指针碰撞”。如果已使用内存和未使用内存交错，就需要一个“空闲列表”方法来决定分配在哪里。</li>
<li>多线程并发时会出现正在给对象A分配内存，还没来得急修改指针，对象B又用这个指针分配内存，这样就出现问题了。解决这种问题有两种方案：1.对分配内存空间的动作进行同步；2.把内存分配动作按照线程划分在不同的空间之中进行，即每个线程在java对中预先分配一小块内存成为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。可以通过-XX:+/-UseTLAB参数决定</li>
<li>内存分配完之后虚拟机将分配到的内存全都初始化为零值。接下来设置对象头，包括这个对象时哪个类的实例，如何才能找到该类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。</li>
<li>执行init方法，初始化  <pre><code>![](D:\markdownpicture/71.png)
</code></pre>
</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li>对象的内存布局包括三个部分：对象头，实例数据和对齐填充。<ul>
<li>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</li>
<li>实例数据：就是数据啦</li>
<li>对齐填充：不是必然的存在，就是为了对齐的嘛</li>
</ul>
</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="B-Tree索引的限制"><a href="#B-Tree索引的限制" class="headerlink" title="B-Tree索引的限制"></a>B-Tree索引的限制</h3><ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
<h3 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h3><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h3 id="Mysql的优化"><a href="#Mysql的优化" class="headerlink" title="Mysql的优化"></a>Mysql的优化</h3><p><a target="_blank" rel="noopener" href="https://dbaplus.cn/news-155-1531-1.html">mysql的优化</a></p>
<ul>
<li><p>慢查询基础：优化数据访问</p>
<ul>
<li><p>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能访问了太多的列（是否向数据库请求了不需要的数据）</p>
<ul>
<li>查询不需要的记录 – 一个常见的错误是常常会误认为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。有些开发者会先使用SELECT语句查询大量的结果，然后获取前面的N行后关闭结果集（例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条）。他们认为MySQL会执行查询，并只返回他们需要的10条数据，然后停止查询。实际情况是MySQL会查询出全部的结果集，客户端的应用程序会接受全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT。</li>
<li>多表关联时返回全部列</li>
<li>总是取出全部列–每次看到SELECT * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必需的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗。</li>
<li>重复查询相同的数据–例如在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样的性能显然会更好。</li>
</ul>
</li>
<li><p>确认MySQL服务器层是否在分析大量超过需要的数据行（MySQL是否在扫描额外的记录）；最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li><p>响应时间</p>
</li>
<li><p>扫描的行数</p>
</li>
<li><p>返回的行数</p>
<p>如果发现查询需要扫描大量的数据但只返回少数的行：</p>
</li>
<li><p>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</p>
</li>
<li><p>改变库表结构。例如使用单独的汇总表</p>
</li>
<li><p>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</p>
</li>
</ul>
</li>
<li><p>重构查询的方式</p>
<ul>
<li><p>一个复杂查询还是多个简单查询。</p>
</li>
<li><p>切分查询：将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
</li>
<li><p>分解关联查询</p>
<ul>
<li>简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MySQL的执行过程</p>
<ul>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器端进行SQL解析、预处理，再由优化器生产对应的执行计划</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
</ul>
</li>
</ul>
<h3 id="慢查询优化步骤"><a href="#慢查询优化步骤" class="headerlink" title="慢查询优化步骤"></a>慢查询优化步骤</h3><ul>
<li><p>先运行看看是否真的很慢，设置为SQL_NO_CACHE</p>
</li>
<li><p>‘1’ where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p>
</li>
<li><p>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p>
</li>
<li><p>order by limit形。。式的sql语句让排序的表优先查</p>
</li>
<li><p>了解业务方使用场景</p>
</li>
<li><p>加索引时参照索引的几大原则</p>
</li>
<li><p>观察结果，不符合预期继续从第一个步骤分析</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">美团技术团队mysql慢查询优化</a></p>
</li>
</ul>
<h3 id="索引-失效情况"><a href="#索引-失效情况" class="headerlink" title="索引-失效情况"></a>索引-失效情况</h3><ul>
<li>对单字段建了索引，where条件多字段</li>
<li>对索引列运算，算法包括（+、-、*、/、！、&lt;&gt;、%、like、or、in、exist），导致索引失效</li>
<li>类型错误，如字段类型为varchar，where条件用number</li>
<li>为null值的时候索引会失效，可以用函数代替掉null，尽量不要让数据允许为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * ,sal + IFNULL(comm,<span class="number">0</span>)FROM emp;</span><br></pre></td></tr></table></figure>

<ul>
<li>在where字句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li>
</ul>
<h3 id="MySql中MyISAM和InnoDB的区别有哪些"><a href="#MySql中MyISAM和InnoDB的区别有哪些" class="headerlink" title="MySql中MyISAM和InnoDB的区别有哪些"></a>MySql中MyISAM和InnoDB的区别有哪些</h3><ul>
<li>InnoDB支持事务，MyISAM不支持事务，这是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败</li>
<li>InnoDB是聚簇索引，MyISAM是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此InnoDB必要要有主键，通过主键索引效率很高。但是辅助索引需要俩次索引，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MYISAM是非聚簇索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ul>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><ul>
<li>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</li>
</ul>
<h3 id="MySql隔离级别和锁"><a href="#MySql隔离级别和锁" class="headerlink" title="MySql隔离级别和锁"></a>MySql隔离级别和锁</h3><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html">链接</a></p>
<h3 id="InnoDb默认的隔离级别"><a href="#InnoDb默认的隔离级别" class="headerlink" title="InnoDb默认的隔离级别"></a>InnoDb默认的隔离级别</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Marvel__Dead/article/details/70209641">链接</a></p>
<ul>
<li>可重复读-保证了主从复制的正确性</li>
</ul>
<h3 id="MySql分库分表"><a href="#MySql分库分表" class="headerlink" title="MySql分库分表"></a>MySql分库分表</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c">分库分表</a></p>
<h3 id="SQL防范注入"><a href="#SQL防范注入" class="headerlink" title="SQL防范注入"></a>SQL防范注入</h3><ul>
<li>PreparedStatement（采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。）</li>
<li>正则表达式过滤传入的参数</li>
<li>关键字过滤</li>
</ul>
<h2 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h2><h3 id="第一家公司（没记得名字）"><a href="#第一家公司（没记得名字）" class="headerlink" title="第一家公司（没记得名字）"></a>第一家公司（没记得名字）</h3><ul>
<li>讲讲mysql的索引<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whgk/p/6179612.html">🔗</a></li>
<li>mysql索引的优化</li>
<li>linux查看日志的命令</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tail:  </span><br><span class="line">   -n  是显示行号；相当于nl命令；例子如下：</span><br><span class="line">        tail -<span class="number">100f</span>      test.log        实时监控<span class="number">100</span>行日志</span><br><span class="line">        tail  -n  <span class="number">10</span>    test.log        查询日志尾部最后<span class="number">10</span>行的日志;</span><br><span class="line">        tail -n +<span class="number">10</span>     test.log        查询<span class="number">10</span>行之后的所有日志;</span><br><span class="line">head:  </span><br><span class="line">    跟tail是相反的，tail是看后多少行日志；例子如下：</span><br><span class="line">        head -n <span class="number">10</span>      test.log   查询日志文件中的头<span class="number">10</span>行日志;</span><br><span class="line">        head -n -<span class="number">10</span>     test.log   查询日志文件除了最后<span class="number">10</span>行的其他所有日志;</span><br><span class="line">cat： </span><br><span class="line">    tac是倒序查看，是cat单词反写；例子如下：</span><br><span class="line">        cat -n test.log |grep <span class="string">&quot;debug&quot;</span>   查询关键字的日志</span><br></pre></td></tr></table></figure>

<ul>
<li>controller线程安全还是不安全<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/413a13b3c9cd">🔗</a></li>
<li>redis和mysql的优缺点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis是一个kv型的nosql，不支持复杂的查询，</span><br><span class="line">单线程，<span class="string">&quot;事务&quot;</span>只满足隔离性，write操作不保证能被持久化，内存大户，一般把数据都放在内存中，</span><br><span class="line">偶尔写入swap中。</span><br><span class="line">mysql是关系型数据库，支持绝大多数sql，多线程，满足acid以及各种隔离级别，</span><br><span class="line">数据保证持久化，数据多存在放磁盘中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>finally和final的区别</p>
</li>
<li><p>mybatis的一二级缓存<br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">链接</a></p>
</li>
</ul>
<h3 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h3><ul>
<li>请问Servlet如何获取用户提交的查询参数以及表单数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值；</span><br><span class="line">通过请求对象的getParameterValues()方法获得包含多个值的参数；</span><br><span class="line">通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>请简述一下线量池的运行流程，使用参数以及方法策略等<br><img src="D:\markdownpicture/72.png"></p>
</li>
<li><p>方法覆盖和方法重载是什么意思？</p>
</li>
<li><p>请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动装箱就是Java自动将原始类型值转换成对应的对象，</span><br><span class="line">比如将<span class="keyword">int</span>的变量转换成Integer对象，这个过程叫做装箱，</span><br><span class="line">反之将Integer对象转换成<span class="keyword">int</span>类型值，这个过程叫做拆箱。</span><br><span class="line">因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>请说明Comparable和Comparator接口的作用以及它们的区别。<br><a href="%F0%9F%94%97">https://blog.csdn.net/tolcf/article/details/52229068</a></p>
</li>
<li><p>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。</span><br><span class="line">在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。</span><br><span class="line">Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。</span><br><span class="line">每一个构造函数必须有它自己唯一的参数列表。</span><br><span class="line">Java不支持像C++中那样的复制构造函数，</span><br><span class="line">这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态和进入阻塞的方法？"><a href="#线程的状态和进入阻塞的方法？" class="headerlink" title="线程的状态和进入阻塞的方法？"></a>线程的状态和进入阻塞的方法？</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mengdd/archive/2013/02/20/2917966.html">链接</a></p>
<h3 id="道一一面"><a href="#道一一面" class="headerlink" title="道一一面"></a>道一一面</h3><ul>
<li>主要针对简历的内容问问题</li>
<li>在上一家公司实习时，做的项目举例一俩件印象深刻的事</li>
<li>你怎么学习项目用到的新技术？</li>
<li>分享一下你未来的书单</li>
<li>你刚才讲到你在看jvm，那你说说垃圾回收机制把</li>
<li>对996什么看法，能接受吗?</li>
<li>你有什么问题问我吗？</li>
</ul>
<h3 id="多益"><a href="#多益" class="headerlink" title="多益"></a>多益</h3><p>笔试部分：</p>
<ul>
<li><p>12345676，用哪种排序算法最快。</p>
</li>
<li><p>下面哪几种排序算法是不稳定-》（快、希、选、堆）（记忆：找到工作就可以“快些找一堆”美女来一起玩了）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md">排序算法的分析</a></p>
</li>
<li><p>mysql的内连接和外连接的区别</p>
</li>
<li><p>TCP粘包。</p>
</li>
<li><p>数据库分为什么保护？答案：安全性控制，完整性控制，并发性控制和数据恢复。</p>
</li>
<li><p>编程题：有几个连通块 。</p>
</li>
<li><p>在一个3 级页表结构的系统中，内存共有8192 页，每页2048 字节。请问内存的物理地址需要多少 ？ 答案是24。</p>
</li>
<li><p>全局变量的优缺点：</p>
<ul>
<li>优点：方便调用，各个函数都可以使用它，不用很麻烦的传递参数。</li>
<li>缺点：<ul>
<li>占用内存单元，全局变量保存在静态存贮区，程序开始运行时为其分配内存，程序结束释放该内存。与局部变量的动态分配、动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。</li>
<li>全局变量破坏了函数的封装性能。函数象一个黑匣子，一般是通过函数参数和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量，那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。</li>
<li>由于多个函数都可能使用全局变量，如果全局对象得到一个不正确的值，则必须查找整个程序以判断错误发生 的位置，对于程序的查错和调试都非常不利。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何向面试官介绍rpc框架</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28e48e5f9c73">rpc框架</a></p>
</li>
<li><p>redis面试题汇总</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1594341157941741587&wfr=spider&for=pc">redis面试题</a></p>
</li>
<li><p>redis的优势</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/edisonOnCall/blog/3044456">redis的优势</a></p>
</li>
<li><p>redis持久化的两种方式详细解析</p>
<p><a target="_blank" rel="noopener" href="https://database.51cto.com/art/202002/610603.htm">rdb和aof</a></p>
</li>
<li><p>Java常考的设计模式</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jianghao233/article/details/82779879">设计模式</a></p>
</li>
<li><p>B树和B+树</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020416577">B树和B+树</a></p>
<ul>
<li><p>B树</p>
<p><img src="D:\markdownpicture\81" alt="1608624821320"></p>
<p>4）每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树的所有关键字都大于它。</p>
</li>
<li><p>B+树</p>
</li>
</ul>
<p><img src="D:\markdownpicture\82" alt="1608630737294"></p>
</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="树的前中后序模板"><a href="#树的前中后序模板" class="headerlink" title="树的前中后序模板"></a>树的前中后序模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">核心思想为：</span></span><br><span class="line"><span class="comment">每拿到一个 节点 就把它保存在 栈 中</span></span><br><span class="line"><span class="comment">继续对这个节点的 左子树 重复 过程1，直到左子树为 空</span></span><br><span class="line"><span class="comment">因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 出栈 并对它的 右子树 重复 过程1</span></span><br><span class="line"><span class="comment">直到遍历完所有节点</span></span><br><span class="line"><span class="comment">接下来我们思考一下前序遍历和后序遍历之间的关系：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">前序遍历顺序为：根 -&gt; 左 -&gt; 右</span></span><br><span class="line"><span class="comment">后序遍历顺序为：左 -&gt; 右 -&gt; 根</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果1： 我们将前序遍历中节点插入结果链表尾部的逻辑，修改为将节点插入结果链表的头部</span></span><br><span class="line"><span class="comment">那么结果链表就变为了：右 -&gt; 左 -&gt; 根</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果2： 我们将遍历的顺序由从左到右修改为从右到左，配合如果1</span></span><br><span class="line"><span class="comment">那么结果链表就变为了：左 -&gt; 右 -&gt; 根</span></span><br><span class="line"><span class="comment">这刚好是后序遍历的顺序</span></span><br><span class="line"><span class="comment">基于这两个思路，我们想一下如何处理：</span></span><br><span class="line"><span class="comment">修改前序遍历代码中，节点写入结果链表的代码，将插入队尾修改为插入队首</span></span><br><span class="line"><span class="comment">修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//前序 第一种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    	stack.pull(root);   	</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.pull(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.pull(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序 第二种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">ineorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty || root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                result.addFirst(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先遍历和广度优先遍历"><a href="#深度优先遍历和广度优先遍历" class="headerlink" title="深度优先遍历和广度优先遍历"></a>深度优先遍历和广度优先遍历</h2><p><img src="D:\markdownpicture\76.png" alt="1606877995850"></p>
<pre><code>//广度优先遍历
class Solution &#123;
public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;      
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    if (root == null) return result;
    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
        int size = queue.size();
        for (int i = 0; i &lt; size; i++) &#123;
            Node node = queue.poll();
            level.add(node.val);
            queue.addAll(node.children);
        &#125;
        result.add(level);
    &#125;
    return result;
    &#125;
&#125;
</code></pre>
<h2 id="深度遍历的递归实现就跟树的前序遍历一样"><a href="#深度遍历的递归实现就跟树的前序遍历一样" class="headerlink" title="深度遍历的递归实现就跟树的前序遍历一样"></a>深度遍历的递归实现就跟树的前序遍历一样</h2><h2 id="利用数组构建二叉树"><a href="#利用数组构建二叉树" class="headerlink" title="利用数组构建二叉树"></a>利用数组构建二叉树</h2><ul>
<li><p>第一种情况 此二叉树不是搜索树，给了先序排列和中序排列即可构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 重建二叉树 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode newNode = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i]==pre[<span class="number">0</span>])&#123;</span><br><span class="line">                newNode.left=reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                newNode.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种情况 此二叉树是搜索树.</p>
<ul>
<li>1、利用前序遍历将数值存在一个数组中，然后序列化的时候加上空格分割数值，这样就完成了序列化操作.</li>
<li>2、根据二叉搜索树的性值：中序遍历的结果是从小到大有序的，所以可以根据前序遍历的结果，获取到前序遍历的数组，然后对数组进行 sort() 排序后，就得到了中序遍历的结果数组，这样利用前序和中序遍历的结果数组,构建一颗二叉树.</li>
</ul>
<h2 id="Java中不常用function"><a href="#Java中不常用function" class="headerlink" title="Java中不常用function"></a>Java中不常用function</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.getOrDefault(x,y) </span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">            ? v</span><br><span class="line">            : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这是源码，意思就是当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List转换成Arrays   </span></span><br><span class="line">String[] s = list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()])</span><br><span class="line"><span class="comment">//但 int数组不行,只能通过遍历</span></span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" rel="tag"># Java面试总结</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/03/20/Tomcat%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/" rel="next" title="Tomcat下载、安装、配置">
      Tomcat下载、安装、配置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.3.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.6.</span> <span class="nav-text">集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9DWEB%E5%AE%89%E5%85%A8%E7%9A%84HTTPS"><span class="nav-number">2.1.</span> <span class="nav-text">确保WEB安全的HTTPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.2.</span> <span class="nav-text">HTTPS的完整性保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%90%8E%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">URL地址栏输入地址后，发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">请求转发与重定向的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">3.1.</span> <span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">3.2.</span> <span class="nav-text">对称加密和非对称加密</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">TCP粘包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%A4%8D%E4%B9%A0"><span class="nav-number">5.</span> <span class="nav-text">Redis复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.1.</span> <span class="nav-text">为什么zset数据结构使用跳表而不使用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Redis%E7%9A%84%E5%88%86%E5%B8%83%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">如何实现Redis的分布锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">6.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">Spring常问问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">7.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">JVM的加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">Java对象的创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">7.3.</span> <span class="nav-text">对象的内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">8.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">8.1.</span> <span class="nav-text">B-Tree索引的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">8.2.</span> <span class="nav-text">索引的优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">Mysql的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">8.4.</span> <span class="nav-text">慢查询优化步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95-%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="nav-number">8.5.</span> <span class="nav-text">索引-失效情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySql%E4%B8%ADMyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">8.6.</span> <span class="nav-text">MySql中MyISAM和InnoDB的区别有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">如何选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81"><span class="nav-number">8.8.</span> <span class="nav-text">MySql隔离级别和锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDb%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">8.9.</span> <span class="nav-text">InnoDb默认的隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">8.10.</span> <span class="nav-text">MySql分库分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E9%98%B2%E8%8C%83%E6%B3%A8%E5%85%A5"><span class="nav-number">8.11.</span> <span class="nav-text">SQL防范注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">面试总结：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%EF%BC%88%E6%B2%A1%E8%AE%B0%E5%BE%97%E5%90%8D%E5%AD%97%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">第一家公司（没记得名字）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95"><span class="nav-number">9.2.</span> <span class="nav-text">模拟面试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BF%9B%E5%85%A5%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">线程的状态和进入阻塞的方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%93%E4%B8%80%E4%B8%80%E9%9D%A2"><span class="nav-number">9.4.</span> <span class="nav-text">道一一面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%9B%8A"><span class="nav-number">9.5.</span> <span class="nav-text">多益</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.</span> <span class="nav-text">树的前中后序模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">2.</span> <span class="nav-text">深度优先遍历和广度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%B0%B1%E8%B7%9F%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%80%E6%A0%B7"><span class="nav-number">3.</span> <span class="nav-text">深度遍历的递归实现就跟树的前序遍历一样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">利用数组构建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E4%B8%8D%E5%B8%B8%E7%94%A8function"><span class="nav-number">5.</span> <span class="nav-text">Java中不常用function</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KingPuiWong</p>
  <div class="site-description" itemprop="description">My Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/KingPuiwong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KingPuiwong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/kingpuii.wong@gmail.com" title="E-Mail → kingpuii.wong@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KingPuiWong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"HyEbcjlGiYDAEpfofczXSH9k-gzGzoHsz","app_key":"m4iIWe2ha4TfovYta4zRjElR","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4791ddfa16b0bbb0f6eb',
      clientSecret: 'ce16879dc65ad3af922ba61c4939950a8abe44cd',
      repo        : 'BlobComment',
      owner       : 'KingPuiWong',
      admin       : ['KingPuiWong'],
      id          : '3e3ea1005bb1e0ddf3414f1b3d7ccd33',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'HyEbcjlGiYDAEpfofczXSH9k-gzGzoHsz',
      appKey     : 'm4iIWe2ha4TfovYta4zRjElR',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
